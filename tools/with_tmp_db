#!/usr/bin/env bash
#
# USAGE:
# echo "<sql>" | with_tmp_db <command>
# The SQL code is used for database initialization.
# The command is executed with postgres available. PGHOST and PGPORT are set accordingly.
# The database is shutdown and the cluster removed when the script exits.
#
set -Eeo pipefail

# restart script as postgres user if run as root
if [ "$(id -u)" = '0' ]; then
  exec su-exec postgres "$0" "$@"
fi

source "$(which docker-entrypoint.sh)"

# finds the max port number of currently active postgresql sockets
function find_max_port() {
  find /var/run/postgresql -maxdepth 1 -type s \
  | sed -re 's/^.*\.([0-9]+)$/\1/g' \
  | sort -nr \
  | head -n1
}
maxport="$(find_max_port)"

PGDATA="$(mktemp -d)"
PGHOST=""
PGPORT="$((${maxport:-5431} + 1))"
export PGDATA PGHOST PGPORT

# hook into docker_ scripts
# shellcheck disable=SC2034
POSTGRES_INITDB_ARGS="--no-locale --nosync --auth=trust"

docker_setup_env
docker_init_database_dir > /dev/null
docker_temp_server_start > /dev/null

docker_setup_db
docker_process_init_files /docker-entrypoint-initdb.d/*

function cleanup() {
  docker_temp_server_stop > /dev/null
  rm -rf "$PGDATA"
}
trap cleanup EXIT

("$@")
